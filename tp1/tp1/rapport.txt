2.1 : Performance instables d'une exec à une autre car il y a d'autre processus en cours d'execution que l'utilisateur ne peut voir. Diff entre user et sys est très grande.
2.2 : avec des outils de profilages comme gprof ou vtune pour les processeurs intel.
2.3 : mult_matrice a le plus grand temps d'exécution

3.1 : voir man gcc
3.2 : option d'opti O0<O1<O2<O3>Os
3.3 : créé un .cgda
3.4 : pas compris

4 : icx plus rapide que gcc

5 : 
	pour gcc :
		-O1 : -fauto-inc-dec -fbranch-count-reg -fcombine-stack-adjustments
           -fcompare-elim -fcprop-registers -fdce -fdefer-pop
           -fdelayed-branch -fdse -fforward-propagate
           -fguess-branch-probability -fif-conversion -fif-conversion2
           -finline-functions-called-once -fipa-profile -fipa-pure-const
           -fipa-reference -fipa-reference-addressable -fmerge-constants
           -fmove-loop-invariants -fomit-frame-pointer -freorder-blocks
           -fshrink-wrap -fshrink-wrap-separate -fsplit-wide-types
           -fssa-backprop -fssa-phiopt -ftree-bit-ccp -ftree-ccp
           -ftree-ch -ftree-coalesce-vars -ftree-copy-prop -ftree-dce
           -ftree-dominator-opts -ftree-dse -ftree-forwprop -ftree-fre
           -ftree-phiprop -ftree-pta -ftree-scev-cprop -ftree-sink
           -ftree-slsr -ftree-sra -ftree-ter -funit-at-a-time
           
		-O2 :Ceux de -O1 + 
		   -falign-functions  -falign-jumps -falign-labels
           -falign-loops -fcaller-saves -fcode-hoisting -fcrossjumping
           -fcse-follow-jumps  -fcse-skip-blocks
           -fdelete-null-pointer-checks -fdevirtualize
           -fdevirtualize-speculatively -fexpensive-optimizations -fgcse
           -fgcse-lm -fhoist-adjacent-loads -finline-small-functions
           -findirect-inlining -fipa-bit-cp  -fipa-cp  -fipa-icf
           -fipa-ra  -fipa-sra  -fipa-vrp
           -fisolate-erroneous-paths-dereference -flra-remat
           -foptimize-sibling-calls -foptimize-strlen -fpartial-inlining
           -fpeephole2 -freorder-blocks-algorithm=stc
           -freorder-blocks-and-partition  -freorder-functions
           -frerun-cse-after-loop -fschedule-insns  -fschedule-insns2
           -fsched-interblock  -fsched-spec -fstore-merging
           -fstrict-aliasing -fthread-jumps -ftree-builtin-call-dce
           -ftree-pre -ftree-switch-conversion  -ftree-tail-merge
           -ftree-vrp
           
		-03 :Ceux de -O2 + 
		   -fgcse-after-reload -finline-functions -fipa-cp-clone
           -floop-interchange -floop-unroll-and-jam -fpeel-loops
           -fpredictive-commoning -fsplit-paths
           -ftree-loop-distribute-patterns -ftree-loop-distribution
           -ftree-loop-vectorize -ftree-partial-pre -ftree-slp-vectorize
           -funswitch-loops -fvect-cost-model
           -fversion-loops-for-strides
           
		-Os :Ceux de -O2 sauf ceux qui augmente souvent la taille du code :
		   -falign-functions  -falign-jumps -falign-labels
           -falign-loops -fprefetch-loop-arrays
           -freorder-blocks-algorithm=stc
           
	pour icx : 
		-O1 : Enables optimizations for speed and disables some optimizations  that
                                increase code size and affect speed. To limit code size, this option:

                                • Enables global optimization; this includes data-flow analysis, code
                                  motion, strength reduction  and  test  replacement,  split-lifetime
                                  analysis, and instruction scheduling.

                                • Disables inlining of some intrinsics.

              This option may set other options. This is
                                determined  by  the compiler, depending on which operating system and
                                architecture you are using. The options that are set may change  from
                                release to release.

              The               O1  option  may  improve performance for applications with very large
                                code size, many branches, and execution time not  dominated  by  code
                                within loops.

		-O2 : Enables  optimizations  for  speed. This is the generally recommended
                                optimization level.  Vectorization is enabled at O2 and  higher  lev‐
                                els.

              This option also enables:

                                • Inlining of intrinsics

                                • Intra-file interprocedural optimization, which includes:

                                  • inlining

                                  • constant propagation

                                  • forward substitution

                                  • routine attribute propagation

                                  • variable address-taken analysis

                                  • dead static function elimination

                                  • removal of unreferenced variables

                                • The following capabilities for performance gain:

                                  • constant propagation

                                  • copy propagation

                                  • dead-code elimination

                                  • global register allocation

                                  • global instruction scheduling and control speculation

                                  • loop unrolling

                                  • optimized code selection

                                  • partial redundancy elimination

                                  • strength reduction/induction variable simplification

                                  • variable renaming
exception handling optimizations

                                  • tail recursions

                                  • peephole optimizations

                                  • structure assignment lowering and optimizations

                                  • dead store elimination

              This option may set other options, especially
                                options  that optimize for code speed. This is determined by the com‐
                                piler, depending on which operating system and architecture  you  are
                                using. The options that are set may change from release to release.

              This content does not apply to SYCL.  On Linux systems, the
                                -debug  inline-debug-info  option  will  be enabled by default if you
                                compile with optimizations (option -O2 or higher)  and  debugging  is
                                enabled (option -g).

              Many routines in the shared libraries are more
                                highly  optimized for Intel(R) microprocessors than for non-Intel mi‐
                                croprocessors.
                                
		-O3 : Performs O2 optimizations and enables more aggressive loop  transfor‐
                                mations  such  as  Fusion,  Block-Unroll-and-Jam,  and  collapsing IF
                                statements.

              This option may set other options. This is
                                determined by the compiler, depending on which operating  system  and
                                architecture  you are using. The options that are set may change from
                                release to release.

              The               O3 optimizations may not cause higher  performance  unless  loop  and
                                memory  access transformations take place. The optimizations may slow
                                down code in some cases compared to O2 optimizations.

              The               O3 option is recommended for applications that have loops that  heav‐
                                ily use floating-point calculations and process large data sets.

              Many routines in the shared libraries are more
                                highly  optimized for Intel(R) microprocessors than for non-Intel mi‐
                                croprocessors.

		-Os : This option enables optimizations that do not increase code size; it  produces  smaller
              code  size  than O2. It disables some optimizations that increase code size for a small
              speed benefit.
              This option tells the compiler to favor transformations  that  reduce  code  size  over
              transformations that produce maximum performance.
              
6 : mkl très très rapide 
7 : perf record -e cycles,cache-misses,instructions,L1-dcache-load-misses,L1-icache-load-misses,branch-instructions,branch-loads,node-loads ./tp1_O0
	voir les screens
